# 网络流问题

图中各边都有一个容量，在图G中从源点s开始到汇点t的流的最大值就是最大流问题。

# 预备知识

图G上的流是一个顶点对上的实函数f，具有以下4个条件。

1. 斜对称。
2. 容量约束
3. 流守恒
4. f(v, v) = 0

定义：一个割{S, T}是把顶点集分成两个自己S T的一个划分，使得s S t T。割的容量c(S, T) 定义为

---

## 图的存储方式(邻接矩阵 & 邻接表)

1. 邻接矩阵

   顶点间的关系存储在一个$n*n​$矩阵M中。若u, v 两个顶点有边，对于无向图有权图，则M[u, v] = M[v, u] = weight[u, v]，对于有向图则有 M[u, v] = weight[u, v]

2. 邻接表

   图的顶点存储在一个线性表中，每个顶点的邻接边都以链表的形式依附在线性表该顶点上。对于有向图，需要θ(n+m)的空间，对于无向图，需要θ(n+2m)的空间。

---

* Dijkstra

```
Dijkstra Algorithm: 单源最短路径
Input	含权有向图G=(V, E), V={1, 2,..., n}
Output	G中顶点1到其他顶点的距离
1    X = {1}, Y = V - {1}； λ[1] = 1
2    for y = 2->n:
3        if y 与 1 相邻: λ[y] = length[1, y]
4        else: λ[y] = +inf
5    for j = 1 -> n-1:
6    	y = argmin(λ[y])  (y∈Y)
7    	X = X ∪ {y}
8    	Y = Y - {y}
9    	for y邻近的每条边 (y, w):
10    		if w ∈ Y and λ[y] + length[y, w] < λ[w]:
11    			λ[w] = λ[y] + length[y, w]
```

可以看到，在第6步，选择Y集合中离X集合最近的点需要O(n)的时间，总共需要循环n-1次。对于**邻接表存储形式**，第9步在整个算法执行过程中需要θ(m)次。算法总**时间复杂度为**$O(n^2 + m)$.

==对于具有非负权的有向图G和一个源点s，算法Dijkstra在**$O(n^2)$**的时间内找到s到图中所有顶点的最短距离。==

---

**贪心算法**一章通过把Y集合构建为最小堆进而把时间复杂度减少到O(mlgn)，对于稠图，时间复杂度为O(m)。

## 图的遍历(DFS/BFS)

对于邻接表存储的形式

1. DFS 时间复杂度为O(m)
2. BFS 时间复杂度为O(m)

# Ford-Fulkerson  福特弗克森方法

```
Alg 161 Ford-Fulkerson
Input 	网络(G, s, t, c)
Output: G 中的一个流
初始化剩余图 R = G
for (u, v) 属于 E
	f(u, v) = 0
end for
while 在R中有一条增广路径 p = s,.., t:
	设Δ为p的瓶颈容量
	for p 中的每条边(u, v):
		f(u, v) = f(u, v) + Δ
	end for
	更新剩余图R
end while
```



